/********************************************************************************/
/*                                                                              */
/* headergen                                                                    */
/*                                                                              */
/* Utility routines for generating static nameprep data tables used by the      */
/* xcode library.                                                               */
/*                                                                              */
/* (c) Verisign Inc., 2000-2003, All rights reserved                            */
/*                                                                              */
/********************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <wchar.h>

#include "headergen.h"
#include "../inc/staticdata/nameprep_datastructures.h"

/*********************************************************************************
*
* Raw data file locations accessed by these routines.
*
**********************************************************************************/

#define OUTPUT_PATH                   "../../../api/c/xcode/inc/staticdata"
#define ILLEGAL_FILE                  "../../../data/Illegal.txt"
#define PROHIBIT_FILE                 "../../../data/Prohibit.txt"
#define CHARMAP_FILE                  "../../../data/Charmap.txt"
#define COMPOSITION_EXCLUSIONS_FILE   "../../../data/CompositionExclusions.txt"
#define UNICODE_DATA_FILE             "../../../data/UnicodeData-3.2.0.txt"
#define RANDALCAT_FILE                "../../../data/BidiRAL.txt"
#define LCAT_FILE                     "../../../data/BidiL.txt"

/* header for .h table data files */

#define STATICHEADERHEADER "\
/********************************************************************/\n\
/* Data Type : %-52s */\n\
/* Version   : %-52s */\n\
/* This file automatically generated by xcode header export utility */\n\
/********************************************************************/\n\n"

#define LINELENGTH 1024

/*********************************************************************************
*
*  Normailzation table data must be sorted for accurate lookups. These structures 
*  temporarily hold data elements which are then sorted and dumped to the nameprep 
*  data header files.
*
**********************************************************************************/

struct _SortData
{
  QWORD key;
  DWORD value;
}; 

typedef struct _SortData SortData;

struct _SortDataStr
{
  DWORD key;
  char  value[256];
}; 

typedef struct _SortDataStr SortDataStr;

static SortData    canonical[1000];
static SortData    compatible[5000];
static SortData    compose[2000];
static SortDataStr decompose[6000];

static int canonical_index   = 0;
static int compatible_index  = 0;
static int compose_index     = 0;
static int decompose_index   = 0;

/* sort comparison function */ 

typedef int (*CMPFUNC)(QWORD, QWORD);

static int cmp(QWORD a, QWORD b)
{
  if (a > b)
    return 1;
  else if (a < b)
    return -1;
  else
    return 0;
}


/*********************************************************************************
*
* Simple bubble sort function for numerical keys with numerical
* values. 
*
**********************************************************************************/

static void arraySort( SortData * data, 
                       CMPFUNC cmp_ptr, 
                       unsigned int the_len )
{
  unsigned int indx;
  unsigned int indx2;
  SortData temp, temp2;
  int flipped;

  if (the_len <= 1)
    return;

  indx = 1; 

  do
  {
    flipped = 0;
    for (indx2 = the_len - 1; indx2 >= indx; --indx2)
    {
      temp.key = data[indx2].key;
      temp.value = data[indx2].value;

      temp2.key = data[indx2 - 1].key;
      temp2.value = data[indx2 - 1].value;

      if ((*cmp_ptr)(temp2.key, temp.key) > 0)
      {
        data[indx2 - 1].key = temp.key;
        data[indx2 - 1].value = temp.value;

        data[indx2].key     = temp2.key;
        data[indx2].value     = temp2.value;

        flipped = 1;
      }
    }
  } while ((++indx < the_len) && flipped);
}
 

/*********************************************************************************
*
* Simple bubble sort function for numerical keys with string
* values. 
*
**********************************************************************************/

static void arraySortStr( SortDataStr * data, 
                          CMPFUNC cmp_ptr, 
                          unsigned int the_len )
{
  unsigned int indx;
  unsigned int indx2;
  SortDataStr temp, temp2;
  int flipped;

  if (the_len <= 1)
    return;

  indx = 1; 

  do
  {
    flipped = 0;
    for (indx2 = the_len - 1; indx2 >= indx; --indx2)
    {
      memcpy( &temp, &data[indx2], sizeof( SortDataStr ) );
      memcpy( &temp2, &data[indx2 - 1], sizeof( SortDataStr ) );
      if ((*cmp_ptr)(temp2.key, temp.key) > 0)
      {
        memcpy( &data[indx2 - 1], &temp, sizeof( SortDataStr ) );
        memcpy( &data[indx2], &temp2, sizeof( SortDataStr ) );
        flipped = 1;
      }
    }
  } while ((++indx < the_len) && flipped);
}



/*********************************************************************************
*
* static int BuildProhibitHeaders( void ) 
* 
*  This function builds the prohibit character table. The table contains a 
*  set of ranges within the boundaries of 00 0000 -> 10 FFFF. 
* 
*  Supports:   Nameprep 11 (RFC 3491)
*  Data file:  Illegal-14.11.07.txt
*
**********************************************************************************/

/*
*
*  struct _ProhibitRangesTable
*  {
*    long low;
*    long high;
*  };
*  typedef struct _ProhibitRangesTable ProhibitRangesTable;
*
*  static ProhibitRangesTable g_prohibitTable[PROHIBIT_ENTRYCOUNT] = 
*  {
*    { low, high },
*    ..
*  }
*
*  - 33 lines/ranges in the Prohibit data file
*  - low / high value for each
*  - single entries are in both high/low values 
*
 */

static int BuildProhibitHeaders( void ) 
{
  unsigned long low, high;
  int params;
  int entryIndex = 0;
  int i;
  ProhibitRangesTable ProhibitTable[1000];

  char filepath[4096];
  char line[LINELENGTH];

  FILE * fp;
  FILE * fpout_prohibit;

  #ifdef AllowUnassigned
  fp = fopen( PROHIBIT_FILE, "r" );
  #else
  fp = fopen( ILLEGAL_FILE, "r" );
  #endif

  #ifdef AllowUnassigned
  sprintf( filepath, "%s/nameprep_prohibit_allowunassigned.h", OUTPUT_PATH );
  #else
  sprintf( filepath, "%s/nameprep_prohibit.h", OUTPUT_PATH );
  #endif

  fpout_prohibit = fopen( filepath, "w" );

  printf( "Generating %s..\n", filepath );

  if ( fp == NULL || fpout_prohibit == NULL ) 
  {
    printf( "Failed to open file.\n" );
    return -1; 
  }

  fprintf( fpout_prohibit, STATICHEADERHEADER, "Prohibit Nameprep Range Table", "11" );

  /* Loop across the data file */

  while ( fgets( line, LINELENGTH, fp ) != NULL ) 
  {
    if (line[0] == '#') {continue;}  /* skip comment lines */
    if ( strlen( line ) < 2 ) {continue;}  /* skip empty lines */

    params = sscanf( line, "%X-%X", &low, &high ); 

    if ( params == EOF || params == 0 ) continue;

    if ( params == 2 ) 
    {
      /* If we have a range entry: */

      ProhibitTable[entryIndex].low  = low;
      ProhibitTable[entryIndex].high = high;
      entryIndex++;

    } else if ( params == 1 )
    {
      /* If we have a single point entry: */

      ProhibitTable[entryIndex].low  = low;
      ProhibitTable[entryIndex].high = low;
      entryIndex++;

    } else {

      printf( "Invalid prohibit data table.\n" );
      return -1;

    }
  } /* end while */

  fprintf( fpout_prohibit, "#define PROHIBIT_ENTRYCOUNT %d\n", entryIndex );
  fprintf( fpout_prohibit, "static const ProhibitRangesTable g_prohibitTable[PROHIBIT_ENTRYCOUNT] = {\n", entryIndex );

  /* dump the header data */

  for( i = 0; i < entryIndex; i++ )
  {
    fprintf( fpout_prohibit, "{ /* low */ 0x%06X, /* high */ 0x%06X },\n", ProhibitTable[i].low, ProhibitTable[i].high );
  }
    
  fprintf( fpout_prohibit, "};" );

  fclose(fp);
  fclose(fpout_prohibit);

  return 1;
}


/*********************************************************************************
*
* static int BuildBidiRandalCatHeaders( void ) 
* 
*  This function builds the bidi randalcat character table. 
* 
*  Supports:   Nameprep 11 (RFC 3491)
*  Data file:  BidiRAL-14.11.07.txt
*
**********************************************************************************/

static int BuildBidiRandalCatHeaders( void ) 
{
  unsigned long low, high;
  int params;
  int entryCount = 0;
  int entryIndex = 0;
  int i, j;
  ProhibitRangesTable ProhibitTable[1000];

  char filepath[4096];
  char line[LINELENGTH];

  FILE * fp;
  FILE * fpout_bidi_randalcat;

  fp = fopen( RANDALCAT_FILE, "r" );

  sprintf( filepath, "%s/nameprep_bidi_randalcat.h", OUTPUT_PATH );
  fpout_bidi_randalcat = fopen( filepath, "w" );

  printf( "Generating %s..\n", filepath );

  if ( fp == NULL || fpout_bidi_randalcat == NULL ) 
  {
    printf( "Failed to open file.\n" );
    return -1; 
  }

  fprintf( fpout_bidi_randalcat, STATICHEADERHEADER, "Bidi Randalcat Lookup Table", "11" );

  /* Loop across the data file */

  while ( fgets( line, LINELENGTH, fp ) != NULL ) 
  {
    if (line[0] == '#') {continue;}  /* skip comment lines */
    if ( strlen( line ) < 2 ) {continue;}  /* skip empty lines */

    params = sscanf( line, "%X-%X", &low, &high ); 

    if ( params == EOF || params == 0 ) continue;

    if ( params == 2 ) 
    {
      /* If we have a range entry: */

      ProhibitTable[entryIndex].low  = low;
      ProhibitTable[entryIndex].high = high;
      entryIndex++;

    } else if ( params == 1 )
    {
      /* If we have a single point entry: */

      ProhibitTable[entryIndex].low  = low;
      ProhibitTable[entryIndex].high = low;
      entryIndex++;

    } else {

      printf( "Invalid randalcat data table.\n" );
      return -1;

    }
  } /* end while */

  /* count */

  for( i = 0; i < entryIndex; i++ )
  {
    for ( j = ProhibitTable[i].low; j <= ProhibitTable[i].high; j++ )
    {
      entryCount++;
    }
  }

  fprintf( fpout_bidi_randalcat, "#define RANDALCAT_ENTRYCOUNT %d\n", entryCount );
  fprintf( fpout_bidi_randalcat, "static const DWORD g_randalcatTable[RANDALCAT_ENTRYCOUNT] = {\n" );

  /* dump the header data */

  for( i = 0; i < entryIndex; i++ )
  {
    for ( j = ProhibitTable[i].low; j <= ProhibitTable[i].high; j++ )
    {
      fprintf( fpout_bidi_randalcat, " 0x%08X,\n", j );
    }
  }
    
  fprintf( fpout_bidi_randalcat, "};" );

  fclose(fp);
  fclose(fpout_bidi_randalcat);

  return 1;
}

/*********************************************************************************
*
* static int BuildBidiLCatHeaders( void )
* 
*  This function builds the bidi randalcat character table. 
* 
*  Supports:   Nameprep 11 (RFC 3491)
*  Data file:  BidiL-14.11.07.txt
*
**********************************************************************************/

static int BuildBidiLCatHeaders( void ) 
{
  unsigned long low, high;
  int params;
  int entryIndex = 0;
  int i;
  ProhibitRangesTable ProhibitTable[1000];

  char filepath[4096];
  char line[LINELENGTH];

  FILE * fp;
  FILE * fpout_bidi_lcat;

  fp = fopen( LCAT_FILE, "r" );

  sprintf( filepath, "%s/nameprep_bidi_lcat.h", OUTPUT_PATH );
  fpout_bidi_lcat = fopen( filepath, "w" );

  printf( "Generating %s..\n", filepath );

  if ( fp == NULL || fpout_bidi_lcat == NULL ) 
  {
    printf( "Failed to open file.\n" );
    return -1; 
  }

  fprintf( fpout_bidi_lcat, STATICHEADERHEADER, "Bidi LCat Lookup Table", "11" );

  /* Loop across the data file */

  while ( fgets( line, LINELENGTH, fp ) != NULL ) 
  {
    if (line[0] == '#') {continue;}  /* skip comment lines */
    if ( strlen( line ) < 2 ) {continue;}  /* skip empty lines */

    params = sscanf( line, "%X-%X", &low, &high ); 

    if ( params == EOF || params == 0 ) continue;

    if ( params == 2 ) 
    {
      /* If we have a range entry: */

      ProhibitTable[entryIndex].low  = low;
      ProhibitTable[entryIndex].high = high;
      entryIndex++;

    } else if ( params == 1 )
    {
      /* If we have a single point entry: */

      ProhibitTable[entryIndex].low  = low;
      ProhibitTable[entryIndex].high = low;
      entryIndex++;

    } else {

      printf( "Invalid randalcat data table.\n" );
      return -1;

    }
  } /* end while */

  fprintf( fpout_bidi_lcat, "#define LCAT_ENTRYCOUNT %d\n", entryIndex );
  fprintf( fpout_bidi_lcat, "static const LCatRangesTable g_lcatTable[LCAT_ENTRYCOUNT] = {\n" );

  /* dump the header data */

  for( i = 0; i < entryIndex; i++ )
  {
    fprintf( fpout_bidi_lcat, "{ /* low */ 0x%06X, /* high */ 0x%06X },\n", ProhibitTable[i].low, ProhibitTable[i].high );
  }
    
  fprintf( fpout_bidi_lcat, "};" );

  fclose(fp);
  fclose(fpout_bidi_lcat);

  return 1;
}

/*********************************************************************************
*
* static int BuildCharmapHeaders( void ) 
* 
*  This function builds the character map character table. The table contains
*  a set of hash indexed records described below. 
* 
*  Supports:   Nameprep 11 (RFC 3491)
*  Data file:  Prohibited-14.11.07.txt
*
**********************************************************************************/

/*
* 
*
* Input data file example:
*
*  character; (mapped to) char1 char2 char3...; Description
*  character; (mapped out) ;                    Description
*
*  1FFB;   1F7D;       Case map
*  1FFC;   03C9 03B9;  Case map
*  200D;   ;           Map to nothing
*  20A8;   0072 0073;  Additional folding
*  2102;   0063;       Additional folding
*  2103;   00B0 0063;  Additional folding
*
* Mapped characters range from 00 00AD to 01 D7BB.
*
* Output data structure:
*
*  The data is stored in a lookup table. Nameprep uses a simple
*  binary search to find an entry or the lack of one. Expansion
*  character lists are either 3 characters, or 0/1/2 with a 
*  terminating null character.
*
*  const DWORD g_charmapTable[CHARMAP_ENTRYCOUNT][4] = {
*    { char, char1, char2, char3, char4 },
*    { char, char1, char2, char3, char4 },
*  }
*
 */

static int BuildCharmapHeaders( void ) 
{
  char filepath[4096];
  char line[LINELENGTH];
  CharmapTable table[10000];

  int entryIndex = 0;
  int params;
  int i,j;

  FILE *fp;
  FILE * fpout_charmap;

  fp = fopen( CHARMAP_FILE, "r" );

  sprintf( filepath, "%s/nameprep_charmap.h", OUTPUT_PATH );
  fpout_charmap = fopen( filepath, "w" );

  printf( "Generating %s..\n", filepath );

  if ( fp == NULL || fpout_charmap == NULL ) 
  {
    printf( "Failed to open charcter map file.\n" );
    return -1; 
  }

  fprintf( fpout_charmap, STATICHEADERHEADER, "Charmap Nameprep Lookup Table", "11" );

  while ( fgets( line, LINELENGTH, fp ) != NULL ) 
  {
    unsigned long root;
    char list[1024];
    
    if (line[0] == '#') {continue;}  /* skip comment lines */
    if ( strlen( line ) < 2 ) {continue;}  /* skip empty lines */

    memset( list, 0, sizeof( list ) );    
    params = sscanf( line, "%X; %[a-z,A-Z,0-9, ]", &root, &list ); 

    if ( params == EOF || params == 0 || params > 2 ) continue;

    /* split the entires up into a list and build our record */

    {
      DWORD c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;

      params = sscanf( list, "%X %X %X %X %X %X", &c1, &c2, &c3, &c4, &c5, &c6, &c7 );

      if ( params > 4 ) 
      { 
        printf("Invalid character map data.\n" );
        return -1;
      }

      if ( params == -1 ) params = 0;

      table[entryIndex].dwCodepoint = root;
      table[entryIndex].length = params;
      table[entryIndex].dwzData[0] = c1;
      table[entryIndex].dwzData[1] = c2;
      table[entryIndex].dwzData[2] = c3;
      table[entryIndex].dwzData[3] = c4;
      entryIndex++;
    }
    
  } /* end while */

  /* now, dump the whole recordArray out in sorted order */

  fprintf( fpout_charmap, "#define CHARMAP_ENTRYCOUNT %d\n", entryIndex );

  fprintf( fpout_charmap, "static const CharmapTable g_charmapTable[CHARMAP_ENTRYCOUNT] = {\n" );

  for( i = 0; i <= 0x0001FFFF; i++ )
  for( j = 0; j < entryIndex; j++ )
  {
    if ( i == table[j].dwCodepoint )
    fprintf( fpout_charmap, "{ /* index */ 0x%08X, /* len, c1->c4 */ %d, { 0x%08X,0x%08X,0x%08X,0x%08X } },\n", 
      table[j].dwCodepoint, table[j].length, table[j].dwzData[0], table[j].dwzData[1], table[j].dwzData[2], table[j].dwzData[3] );
  }

  fprintf( fpout_charmap, "};" );

  fclose( fp );
  fclose( fpout_charmap );

  return 0;
}

/*********************************************************************************
*
* static int LoadExclusionChars( void ) 
*                      
*  Loads exclusion data into a temporary lookup table. This data is used in
*  BuildNormalizationHeaders in generating decomposition lookup tables.
*
*  Supports:   Nameprep 11 (RFC 3491)
*  Data file:  CompositionExclusions-3.2.0.txt
*
**********************************************************************************/

static unsigned long ExclusionCharacterList[100];
static int exclusionListLength = 0;

static int LoadExclusionChars( void ) 
{
  FILE *fp;
  char line[LINELENGTH];
  char * token;
  unsigned long exchar = 0;
  int entryIndex = 0;

  memset( ExclusionCharacterList, 0, sizeof( ExclusionCharacterList ) );

  if ((fp = fopen( COMPOSITION_EXCLUSIONS_FILE, "r" ) ) == NULL ) 
  {
    return -1; 
  }

  while (fgets(line, LINELENGTH, fp) != NULL) 
  {
    if (line[0] == '#') {continue;}  /* skip comment line */

    if ((token = strtok(line, " #\n")) == NULL) 
    {
      continue; /* skip blank line */

    } else {
      
      sscanf( token, "%x", &exchar );

      ExclusionCharacterList[entryIndex] = exchar;
      entryIndex++;

    }
  } /* end while */

  exclusionListLength = entryIndex;

  fclose(fp);

  return 1;
}

static int LookupExclusionChar( unsigned long c ) 
{
  int i;
  for ( i = 0; i < exclusionListLength; i++ )
  {
    if ( ExclusionCharacterList[i] == c ) return 1;
  }
  return 0;
}

/*********************************************************************************
*
* int HexStrToDword( char * hexstr, DWORD out[] )
* 
*  Parses a ASCII Unicode datafile hex representation of unicode sequence 
*  separated by spaces into a 32-bit character string.
*
*  char * hexstr - The hex string to be parsed. Example: "031E 20A0 0035"
*  DWORD out     - The target string. The caller must allocate enough storage 
*
**********************************************************************************/

int HexStrToDword( char * hexstr, DWORD out[] ) 
{
  DWORD  codepoint;
  int    index = 0;
  char * token;

  if (!hexstr) 
  {
    out[0] = 0;
    return 0;
  }

  token = strtok(hexstr, " ");
  sscanf( token, "%x", &codepoint ); 

  out[index] = codepoint;
  index++; 

  while ( ( token = strtok(NULL, " " ) ) != NULL ) 
  {
    sscanf( token, "%x", &codepoint );
    out[index] = codepoint;
    index++;
  } 

  out[index] = 0;
  return index;
}


/*********************************************************************************
*
* static int BuildNormalizationHeaders( void ) 
* 
*  This function builds canonical class, compatibility, compose and decompose
*  lookup data tables used in nameprep.
* 
*  Supports:   Nameprep 11 (RFC 3491)
*  Data file:  Prohibited-14.11.07.txt
*
**********************************************************************************/

static int BuildNormalizationHeaders( void ) 
{
  char          line[LINELENGTH];
  DWORD         mapseq[LINELENGTH];
  char          token[LINELENGTH];
  char *        begin;
  char *        substr;
  char          hexcode[10];
  DWORD         codepoint;
  DWORD         canonicalClass;
  QWORD         pair;
  int           found;
  int           seqlen;

  FILE * fp;
  FILE * fpout_canonical;
  FILE * fpout_compose;
  FILE * fpout_compatible;
  FILE * fpout_decompose;

  char filepath[4096];

  int i;

  codepoint = 0;
  seqlen = 0;

  /* reset our sorting tables */

  memset( canonical, 0, sizeof( canonical ) );
  memset( compatible, 0, sizeof( compatible ) );
  memset( compose, 0, sizeof( compose ) );
  memset( decompose, 0, sizeof( decompose ) );

  /* Load exclusion data */

  if ( LoadExclusionChars() == -1 )
  {
    printf( "Failed to load composition exclusion data.\n" );
    return -1;
  }
   
  /* create header files */

  sprintf( filepath, "%s/nameprep_cononical.h", OUTPUT_PATH );
  fpout_canonical     = fopen( filepath, "w" );

  printf( "Generating %s..\n", filepath );

  sprintf( filepath, "%s/nameprep_compatible.h", OUTPUT_PATH );
  fpout_compatible = fopen( filepath, "w" );

  printf( "Generating %s..\n", filepath );

  sprintf( filepath, "%s/nameprep_compose.h", OUTPUT_PATH );
  fpout_compose       = fopen( filepath, "w" );

  printf( "Generating %s..\n", filepath );

  sprintf( filepath, "%s/nameprep_decompose.h", OUTPUT_PATH );
  fpout_decompose     = fopen( filepath, "w" );

  printf( "Generating %s..\n", filepath );

  fp = fopen( UNICODE_DATA_FILE, "r" );

  if ( fp               == NULL ||
       fpout_canonical  == NULL ||
       fpout_compose    == NULL ||
       fpout_decompose  == NULL ||
       fpout_compatible == NULL ) 
  { 
    printf( "Failed to open normalization file.\n" );
    return -1; 
  }

  /* iterate across the unicode data file */

  while (fgets(line, LINELENGTH, fp) != NULL) 
  {
    int fCompat = 0;

    if (line[0] == '#') {continue;} /* skip comment line */

    /* 1. grab the hex codepoint value */

    if ((substr = strchr(line, ';')) == NULL) {continue;} /* skip blank line */

    begin = line;

    //00BC;VULGAR FRACTION ONE QUARTER;No;0;ON;<fraction> 0031 2044 0034;;;1/4;N;FRACTION ONE QUARTER;;;;

    if (substr - begin != 0) 
    {
      strncpy(hexcode, begin, substr-begin);
      hexcode[substr-begin] = '\0';
      strcpy(token, hexcode);
      sscanf(token, "%x", &codepoint); /* value of unicode codepoint */
    }

    /* 2. Description - not used */

    begin = substr + 1;
    if ((substr = strchr(begin, ';')) == NULL) {continue;}
 
    /* 3. Skip */

    begin = substr + 1;
    if ((substr = strchr(begin, ';')) == NULL) {continue;}

    /* 4. canonical combining class value */

    begin = substr + 1;
    if ((substr = strchr(begin, ';')) == NULL) {continue;}

    if (substr - begin != 0) 
    {
     strncpy(token, begin, substr-begin);
     token[substr-begin] = '\0';
     sscanf(token, "%d", &canonicalClass);
    }

    //00BC;VULGAR FRACTION ONE QUARTER;No;0;ON;<fraction> 0031 2044 0034;;;1/4;N;FRACTION ONE QUARTER;;;;
    //                                    ^

    /* check if canocical class is within 0 - 255 */
     
    if (canonicalClass != (canonicalClass & 0xFF)) 
    {
      printf( "Invalid Unicode data file. (cononical class)\n" );
      return -1;
    }

    if ( canonicalClass != 0 )
    {
      canonical[canonical_index].key = codepoint;
      canonical[canonical_index].value = canonicalClass;
      canonical_index++;
    }

    //00BC;VULGAR FRACTION ONE QUARTER;No;0;ON;<fraction> 0031 2044 0034;;;1/4;N;FRACTION ONE QUARTER;;;;
    //                                      ^

    /* 5. bidirectional */

    begin = substr + 1;
    if ((substr = strchr(begin, ';')) == NULL) {continue;}


    //00BC;VULGAR FRACTION ONE QUARTER;No;0;ON;<fraction> 0031 2044 0034;;;1/4;N;FRACTION ONE QUARTER;;;;
    //                                         ^

    /* 6. decomposition */

    begin = substr +1;
    if ((substr = strchr(begin, ';')) == NULL) {continue;}

    if (substr - begin != 0) 
    {
      char *decompose_token;

      strncpy(token, begin, substr-begin);
      token[substr-begin] = '\0';

      /* Check for a <msg> which implies compatability. */
      /* 2E9F;CJK RADICAL MOTHER;So;0;ON;<compat> 6BCD;;;;N;;;;; */
      /* 2F9ED;CJK COMPATIBILITY IDEOGRAPH-2F9ED;Lo;0;L;28BFA;;;;N;;;;; */

      if (token[0] == '<') 
      {
        /* this character has a compatible codepoint */

        compatible[compatible_index].key = codepoint;
        compatible[compatible_index].value = 1;
        compatible_index++;

        if ((decompose_token = strchr(token, '>')) == NULL) /* skip '>' */ 
        {
          printf( "Invalid Unicode data file. (decompose token)\n" );
          return -1;
        }

        strcpy(token, decompose_token+2);
        fCompat = 1;
      }

      /* now retrieve the replacement codepoint sequence  and store
         it in the decompose table. */

      /* "05D0 05DC" -> "{0x05D0,0x05DC,0x0000}" */

      {
        char buffer[256];
        char result[256];
        memset( buffer, 0, 256 );
        memset( result, 0, 256 );
        strcpy( buffer, token );
        strcpy( result, "{0x" );

        for( i = 0; i < strlen( buffer ); i++ )
        {
          if ( buffer[i] == ' ' )
          {
            strcat( result, ",0x" );
          } else {
            strncat( result, &buffer[i], 1 );     
          }          
        } 

        strcat( result, ",0x0000}" );

        decompose[decompose_index].key = codepoint;

        strcpy( decompose[decompose_index].value, result );

        decompose_index++;
      }

      /* 1D1BD;MUSICAL SYMBOL SEMIMINIMA WHITE;So;0;L;1D1BB 1D16E;;;;N;;;;;*/

      /* process mapping sequence */

      seqlen = HexStrToDword( token, mapseq ); 

      if ( seqlen < 1 || ( seqlen > 2 && !fCompat ) ) 
      {
        printf( "Invalid Unicode data file. (seqlen)\n" );
        return -1;
      }

      /* store composition pairs */

      found = LookupExclusionChar( codepoint );

      if ( fCompat == 0 && found == 0 ) 
      {
        DWORD first, second;  

        if ( seqlen > 1 ) 
        {
          first   = mapseq[0];
          second  = mapseq[1];
        } else {
          first   = 0;
          second  = mapseq[0];
        }

        pair = first;
        pair = (pair << 32) | second;

        compose[compose_index].key   = pair;
        compose[compose_index].value = codepoint;
        compose_index++;
      }
    } /* end decomposition */
  } /* end while */

  printf( "Compose dataset length:    %d\n", compose_index - 1 );
  printf( "Decompose dataset length:  %d\n", decompose_index - 1 );
  printf( "Compatible dataset length: %d\n", compatible_index - 1 );
  printf( "Canonical dataset length:  %d\n", canonical_index - 1 );

  /* print the fpout data structure headers */

  fprintf( fpout_canonical, STATICHEADERHEADER, "Canonical Normalize Lookup Table", "11" );
  fprintf( fpout_canonical, "#define CANONICAL_ENTRYCOUNT %d\n", canonical_index );
  fprintf( fpout_canonical, "static const CanonicalTable g_canonicalTable[CANONICAL_ENTRYCOUNT] = {\n" );

  fprintf( fpout_compatible, STATICHEADERHEADER, "Compatibility Normalize Lookup Table", "11" );
  fprintf( fpout_compatible, "#define COMPATIBLE_ENTRYCOUNT %d\n", compatible_index );
  fprintf( fpout_compatible, "static const DWORD g_compatibleTable[COMPATIBLE_ENTRYCOUNT] = {\n" );

  fprintf( fpout_compose, STATICHEADERHEADER, "Composition Normalize Lookup Table", "11" );
  fprintf( fpout_compose, "#define COMPOSE_ENTRYCOUNT %d\n", compose_index );
  fprintf( fpout_compose, "static const ComposeTable g_composeTable[COMPOSE_ENTRYCOUNT] = {\n" );

  fprintf( fpout_decompose, STATICHEADERHEADER, "Decomposition Normalize Lookup Table", "11" );
  fprintf( fpout_decompose, "#define DECOMPOSE_ENTRYCOUNT %d\n", decompose_index );
  fprintf( fpout_decompose, "static const DecomposeTable g_decomposeTable[DECOMPOSE_ENTRYCOUNT] = {\n" );

  /* sort tables that require it and dump the result to the header files */

  printf( "Sorting compose data.." );

  arraySort(compose, cmp, compose_index );

  for( i = 0; i < compose_index; i++ ) 
  {
    fprintf(fpout_compose, "{ /* cp pair */ 0x%08X%08X, /* composed */ 0x%08X},\n", 
      (unsigned long)(compose[i].key >> 32), (unsigned long)(compose[i].key & 0x00000000FFFFFFFF),
      compose[i].value );
  }

  printf( "done.\n" );

  printf( "Sorting canonical data.." );

  arraySort(canonical, cmp, canonical_index );

  for( i = 0; i < canonical_index; i++ ) 
  {
    DWORD k = (DWORD)canonical[i].key;
    DWORD v = (DWORD)canonical[i].value;
    fprintf(fpout_canonical, " { /* cp */ 0x%08X, /* class */ 0x%08X},\n", k,v );
  }

  printf( "done.\n" );

  printf( "Sorting compatible data.." );

  arraySort(compatible, cmp, compatible_index );

  for( i = 0; i < compatible_index; i++ ) 
  {
    fprintf(fpout_compatible, " 0x%08X,\n", compatible[i].key );
  }

  printf( "done.\n" );

  printf( "Sorting decompose data.." );

  arraySortStr(decompose, cmp, decompose_index );

  for( i = 0; i < decompose_index; i++ ) 
  {
    int j, count = 0;
    for ( j = 0; j <= 256; j++ )
    {
      if ( decompose[i].value[j] == ',' ) count++;
      if ( decompose[i].value[j] == '}' ) break;
    }
    fprintf(fpout_decompose, "{ /* cp */ 0x%08X, /*len */ %d, /* decomp */ %s},\n", decompose[i].key, count, decompose[i].value );
  }

  printf( "done.\n" );

  /* static data closing headers */

  fprintf(fpout_canonical, "};" );
  fprintf(fpout_compose, "};" );
  fprintf(fpout_compatible, "};" );
  fprintf(fpout_decompose, "};" );

  fclose(fpout_canonical		);
  fclose(fpout_compose		);
  fclose(fpout_compatible	);
  fclose(fpout_decompose		);

  fclose(fp);

  printf( "Complete.\n" );

  return 1;
}

/*********************************************************************************
*
* int Xcode_buildDataTables( void )
*  
*  Build all static data tables compiled into the xcode library.
*
**********************************************************************************/

int Xcode_buildDataTables( void )
{
  /* Prohibit data table */

  if ( BuildProhibitHeaders() == -1 ) return -1;

  if ( BuildBidiRandalCatHeaders() == -1 ) return -1;

  if ( BuildBidiLCatHeaders() == -1 ) return -1;

  if ( BuildCharmapHeaders() == -1 ) return -1;

  if ( BuildNormalizationHeaders() == -1 ) return -1;
  
  return 1;
}

